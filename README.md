# non-blocking-output-case

-  C++ 파일을 테스트하기 위해 개발되었습니다.
- C++의 cin와 cout 버퍼를 비우지 않아도(no flush) 적절히 출력 내용을 확인할 수 있습니다.
- (응용) `get()`와 `write()`를 적절히 활용하여 입력 이전의 출력 내용 앞에 입력값을 덧붙여 올바른 출력 내용을 얻을 수 있습니다.
- `\n` 줄바꿈을 감지하면 자동으로 버퍼링되어 라인에 저장됩니다. (즉 read()와 readline() 두 함수의 역할을 합니다.)

## Contribute
- 데이터를 삽입할 땐 `write()`를 사용하세요. 
- 데이터를 가져오고자 할 때는 입력 이후에 `get()`를 사용하세요. (완전히 출력될 때 까지 이 함수는 블로킹 상태가 됩니다)
- 종료할 때는 `exit()`를 사용하세요. 사용하지 않으면 자발적으로 프로세스를 종료할 수 없습니다.

## How did you implement it?
Thread `clock`와 `read_output`가 상호작용하며 데이터를 입력받는 구조로 진행됩니다. `read_output` Thread에서는 프로세스 내에 있는 출력 버퍼의 데이터를 가져오고 이를 `cur_line` 전역 변수에 데이터를 넣습니다, 단 데이터는 문자 하나이며 전역 변수는 가변 객체이어야 합니다. 이 가변 객체를 구현하기 위해 **StringIO** 객체를 사용했습니다. 문자 하나 넣을 때 마다 `cur_output_last_time` 전역 변수에 `time`를 새로 할당합니다.

`clock` Thread에서는 마지막으로 `cur_line` 변수에 넣은지 0.3초 지났거나 `cur_line`의 문자 마지막이 줄바꿈이라면 `lines` 변수에 `cur_line`의 문자열을 넣고 `cur_line`를 비웁니다. 단 인스턴스를 새로 할당하지 않고, 특정 함수를 이용하여 자동으로 비우도록 합니다. 그리고 출력중인지 아닌지 플래그를 전달하기 위해 `outputting` 변수를 `False` 또는 `True`로 실시간으로 확인할 수 있게 했습니다.

`get()`에서는 `outputting`가 `True`이라면 기다리게 하고, 값이 바뀌면 그때야 `lines` 변수를 반환합니다.

`write()` 내부에서는 프로세스의 입력 버퍼에 데이터를 집어넣고 이를 flush합니다.

`exit()`는 일반적으로 프로세스를 직접 종료할 수 없으므로 `stop_flag` 플래그를 사용하여 모든 Thread를 종료하고, 메인 스레드마저 종료할 수 있게 설계되어있습니다.

`start_observation`는 args를 적절히 받아 프로세스를 새로 할당하고, `clock`와 `read_output` Thread를 생성하는 역할을 합니다.

## Maintenance
`Contribute`에 적힌 규칙만 따라주시면 언제든지 소스코드를 가져가셔도 좋습니다. 이외에도 라이센스를 꼭 준수해주세요.

